---
title: 実装計画書
project: "AI-First Project"
version: "v1.0"
owner: "Team AI First"
last_updated: "2025-12-24"
---

# 1. 概要
## 1.1 目的
- チームで並行実装しつつ、依存関係を崩さず効率的に開発する
- 設計ドキュメントに基づき、手戻りのない実装ラインを構築する
- この計画書をもとにメンバーへタスクを割り振り、進捗を管理する

## 1.2 成果物（最終ゴール）
- リリース対象: <Webアプリケーション>, <APIサーバー>
    - 例: Web（Next.js）, API（Go/Node.js）
- リリース形態: 初期リリース (MVP)
- リリース日（目標）: TBD

## 1.3 スコープ
### In Scope
- <機能を列挙>
    - 例: **ユーザー・認証**: 登録(F-01)、ログイン(F-02)、マイページ(F-03)
    - 例: **商品**: 商品一覧、商品詳細、在庫管理
    - 例: **注文**: 注文作成、注文履歴
    - 例: **管理機能**: 商品管理ダッシュボード

### Out of Scope（今回やらない）
- 決済ゲートウェイ連携（モックで対応）
- 複雑なプロモーション/クーポン機能
- 高度な分析・レポーティング基盤

## 1.4 参照ドキュメント
> 実装の前提となる「合意済みの設計」をリンクする。変更が入る場合は、必ず設計書→実装の順で更新する。

- `templates/design/01_basic_design.md`（機能一覧 / 画面遷移）
- `templates/design/screen/<feature-name>_screen_design.md`（画面仕様）
- `templates/design/db/03_db_design.md`（ER図 / テーブル定義）
- `templates/design/02_api_design.md`（API IF / OpenAPI）
- `templates/design/04_architecture_design.md`（アーキテクチャ / ディレクトリ構成）
- `templates/design/05_non_functional_requirements.md`（非機能要件）
- `templates/design/09_roles_permissions.md`（権限 / ロール）

## 1.5 前提・制約
- 技術スタック:
    - Frontend: Next.js / React
    - Backend: Go (or Node.js)
    - Database: PostgreSQL
    - Infra: Docker / AWS/GCP
- アーキテクチャ: レイヤードアーキテクチャ (Presentation, Application, Domain, Infrastructure)

---

# 2. 開発の進め方（チーム戦略）

## 2.1 チーム構成と役割分担
複数人で並行実装しつつ品質を担保するため、以下のような役割分担を推奨します。
> ポイント: 全員が「自分の担当範囲のDRI（Directly Responsible Individual）」を持つ。曖昧さをなくす。

| ロール | 人数目安 | 主な責務 | 担当領域 |
|---|---|---|---|
| **Tech Lead** | 1名 | アーキテクチャ決定、共通基盤実装、コードレビュー | 基盤 / 難易度高の機能 |
| **Frontend Engineer** | 1-2名 | UIコンポーネント実装、画面結合、API繋ぎ込み | Presentation Layer |
| **Backend Engineer** | 1-2名 | API実装、DB設計・構築、ビジネスロジック | Application / Domain / Infra |
| **QA / PM** | 1名 | 仕様策定、受入テスト、進捗管理 | 要件 / テスト |

## 2.2 タスクの割り振り方（衝突を減らす戦略）
### 原則
- **境界で割る**: ドメイン（Users / Products / Orders など）または機能スライス単位に担当を固定し、同じファイルを複数人が同時編集しない。
- **共通基盤は集中実装**: セットアップ/CI/認証/共通UIなどはTech Lead（+サポート）で先に整備し、以降の実装を並列化する。
- **決める人を決める**: 迷いが出やすい論点（API形式/認証方式/エラー形式）はDRIを置き、議論を短時間で収束させる。

### 割り振りパターン（おすすめ）
- **縦割り（推奨）**: 1ドメインを1人（または1ペア）が「DB → API → UI」まで持つ（手戻りが最小・認知負荷が低い）。
- **横割り（専門性重視）**: FE/BEで分ける場合は **Contract First（API IF先行）** + **モック/スタブ** で待ち時間を消す。

### 例: 3人チーム（TL + FE + BE）
- TL: 基盤（CI/環境/共通規約）と、レビュー・設計合意の最終責任
- FE: 画面/コンポーネントと、OpenAPIクライアント等のIF同期
- BE: DB/Usecase/API実装（認証とコアドメイン）

### 例: 5人チーム（TL + FE2 + BE2）
- Users / Products / Orders で **ドメインDRI** を置き、相互にレビューして局所最適を防ぐ
- FEは「画面群」で割る（例: カタログ系 / 管理画面系）と衝突が減る

## 2.3 ブランチ/タスク運用
- **ブランチ戦略**: GitHub Flow (mainブランチ守り)
    - feature/xxx ブランチで開発し、PRでマージ。
- **タスク粒度**: 
    - 1タスク = 1 PR を基本とする（大きすぎない粒度）。
    - 例: 「商品一覧API実装」「商品一覧UI実装」「DBマイグレーション作成」
- **先行着手**:
    - **Interface First**: APIのIF（OpenAPI等）を最初に合意し、FE/BEが並走できるようにする。

## 2.4 並行開発を成立させる鍵（Contract / Stub / Feature Flag）
- **Contract First**: OpenAPI（or gRPC proto）をPRで合意し、破壊的変更は必ずレビュー対象にする。
- **Stub First**: FEはAPIモック（MSW等）で先行し、BEはハンドラのスケルトン（200/4xx/5xx）から埋める。
- **Feature Flag**: 未完の機能はフラグで隠し、mainに小さくマージして統合コストを下げる。

## 2.5 PR設計のルール（レビュー滞留と衝突を防ぐ）
- 目安: **0.5〜1日で完了** / **差分は小さく**（レビューが30分以内で終わるサイズ）
- ルール: 「DB変更 + API変更 + UI変更」を同一PRに詰め込み過ぎない（結合が必要な場合はスライスとして意図的にまとめる）
- 進捗可視化: `templates/<feature-name>_tasks.md` をコピーし、PRの受け入れ基準と変更ファイルを明記する

## 2.6 進捗管理（おすすめの運用）
- カンバン（Backlog / Ready / In Progress / Review / Done）で管理し、**WIPは1人1件** を基本にする
- 定例:
    - デイリー（15分）: ブロッカー共有・依存関係の早期発見
    - 週次（30〜60分）: スコープ調整・次スプリントの合意
    - レトロ（30分）: 衝突/手戻りの原因を次に反映

## 2.7 Definition of Done（DoD）
- 受け入れ基準が満たされ、主要ケースの手動確認が完了
- テスト（ユニット/統合/スモーク）の追加、または不要な理由が明記されている
- ログ/エラーハンドリング/認可（必要な場合）が実装されている
- 設計・IF・マイグレーションが最新である（設計差分がある場合は先に更新）

## 2.8 開発フロー（並行作業のコツ）
1. **設計固定**: DB設計とAPI IFをTech Lead中心に固める。
2. **基盤実装**: 共通コンポーネント、ベースレイアウト、認証基盤を先行実装。
3. **ドメイン並行**: 「ユーザー」「商品」「注文」のドメインごとに担当を割り振り並行開発。
    - **BE**: DB → Repository → UseCase → Handler の順で実装。
    - **FE**: UIコンポーネント → ページ実装 → ダミーデータでの挙動確認 → API繋ぎ込み。

---

# 3. 依存関係の整理

## 3.1 機能カタログ (Based on Basic Design)
> ここは `templates/design/01_basic_design.md` の機能一覧をもとに更新する（IDは一度決めたら変えない）。

| ID | 機能名 | 依存機能 | 備考 |
|---|---|---|---|
| F-01 | ユーザー登録 | - | Guest |
| F-02 | ログイン | F-01 | 認証トークン発行 |
| F-03 | マイページ | F-02 | 認証必須 |
| F-04 | 商品一覧 | - | 誰でも閲覧可 |
| F-05 | 商品詳細 | F-04 | |
| F-06 | 注文作成 | F-02, F-05 | ユーザーかつ商品が必要 |
| F-07 | 注文履歴 | F-06 | |

## 3.2 開発順序（推奨）
依存関係に基づき、以下の順序で着手します。

1. **共通基盤**: プロジェクトセットアップ、Docker、CI、Lint
2. **Usersドメイン**: 認証は全てのガードになるため最優先 (F-01, F-02)
3. **Productsドメイン**: 注文の前提となる商品データ (F-04, F-05)
4. **Ordersドメイン**: 最も依存が多い機能 (F-06, F-07)

## 3.3 依存関係を崩さないための運用ルール
- **破壊的変更**（DBスキーマ/エンドポイント/レスポンス形式）は「移行期間を設ける（旧+新の両対応）」か「同日中に同時マージ」する
- **設計→実装の順**を徹底し、実装中の気づきは設計へフィードバック（PRで差分管理）
- 依存が大きい領域（認証/共通エラー/共通UI）は **変更頻度を下げる**（決定事項として固定し、変更は合意制にする）

---

# 4. フェーズ別 実装計画

## Phase 0: 合意形成（Design Freeze）
- [ ] MVPスコープ確定（In/Outの合意）
- [ ] DB設計（ER図・主要テーブル・マイグレーション方針）
- [ ] API IF確定（OpenAPI・認証方式・エラー形式）
- [ ] 権限/ロールの合意（アクセス制御の境界）

## Phase 1: プロジェクト基盤構築 (Setup)
- [ ] リポジトリ初期化 (Monorepo or Separate)
- [ ] Docker環境構築 (App, DB)
- [ ] DBマイグレーションツール導入
- [ ] CI/CDパイプラインセットアップ (Lint/Build)

## Phase 2: 認証・ユーザー基盤 (Users Domain)
- [ ] DB: Usersテーブル作成
- [ ] API: 登録・ログインAPI実装 (JWT発行)
- [ ] FE: ログイン・登録画面実装
- [ ] FE: 認証ガード（Middleware/HOC）実装

## Phase 3: 商品カタログ (Products Domain)
- [ ] DB: Productsテーブル作成 (初期データシード含む)
- [ ] API: 商品一覧・詳細取得API
- [ ] FE: 商品カタログUI作成
- [ ] FE: 検索・フィルタリングUI

## Phase 4: 注文機能 (Orders Domain)
- [ ] DB: Orders, OrderItemsテーブル作成
- [ ] API: 注文作成トランザクション実装
- [ ] FE: カート・注文確認画面
- [ ] FE: 注文履歴画面

## Phase 5: 結合テスト・品質向上
- [ ] 全通しテスト（E2E）
- [ ] バグ修正
- [ ] UIブラッシュアップ

---

# 5. リスク管理
- **API定義の変更**: 後から変更が入るとFE/BE双方に手戻りが発生する。
    - **対策**: Swagger/OpenAPIで先に定義し、変更時は必ずレビューを通す。
- **仕様の認識齟齬**:
    - **対策**: デザイン(UI)とER図(DB)を突き合わせて、「この画面のこのデータはどこから来るか」を早めに確認する。
- **PRが大きくレビューが滞留**:
    - **対策**: PRを小さく（0.5〜1日）/ WIP制限 / レビュー当番制 / ペア作業で即時解決。
- **結合が後ろ倒しになり不具合が蓄積**:
    - **対策**: スモークE2Eを最初に用意し、日次でmainへ統合（Feature Flag前提）。
